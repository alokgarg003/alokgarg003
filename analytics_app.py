
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Streamlit Dashboard – Run Analytics (Consolidated)
--------------------------------------------------
Visualize analytics generated by run_analytics.py:
- Uses sibling folder: outputs_partitioned/run_<timestamp>_analytics
- Reads: _logs/analytics_summary.json, master_analytics.xlsx, and per-scenario tables.
- Works with outputs in XLSX or CSV format.

Run:
  streamlit run analytics_app.py
"""

from __future__ import annotations

from pathlib import Path
import json
from typing import Optional, Dict, List, Tuple

import pandas as pd
import numpy as np
import streamlit as st
import plotly.express as px
import plotly.graph_objects as go

# ---------- Config ----------
DEFAULT_OUT_ROOT = Path("outputs_partitioned")
SCENARIOS = [
    "stuck-files", "ftp-errors", "config-file", "err-file-remove",
    "callout/mfterr03", "callout/mfterr04", "process-alert", "warnings", "misc"
]
PREVIEW_LIMIT = 10000

# Per-scenario base names emitted by run_analytics.py
TABLE_MAP: Dict[str, List[str]] = {
    "stuck-files": ["stuck_paths_counts", "stuck_paths_stats", "stuck_top_interfaces"],
    "ftp-errors": ["ftp_by_verb", "ftp_by_code", "ftp_iface_verb_code", "ftp_permission_connectivity"],
    "config-file": ["config_bad_paths", "config_top_interfaces"],
    "err-file-remove": ["err_remove_by_interface", "err_remove_paths"],
    "callout/mfterr03": ["callout_mfterr03_interfaces", "callout_mfterr03_hosts"],
    "callout/mfterr04": ["callout_mfterr04_interfaces", "callout_mfterr04_hosts"],
    "process-alert": ["process_alert_by_interface", "process_alert_time"],
    "warnings": ["warnings_hosts", "warnings_fs_paths"],
    "misc": ["misc_top_tokens", "misc_error_codes"],
}

# ---------- Helpers ----------
def list_runs(out_root: Path) -> list[Path]:
    if not out_root.exists():
        return []
    runs = sorted([p for p in out_root.iterdir() if p.is_dir() and p.name.startswith("run_")])
    return runs[::-1]  # newest first

def compute_analytics_dir(run_dir: Path) -> Path:
    return run_dir.parent / f"{run_dir.name}_analytics"

def _find_first_existing(base: Path) -> Optional[Path]:
    # Prefer xlsx, fallback to csv
    xlsx = base.with_suffix(".xlsx")
    if xlsx.exists():
        return xlsx
    csv = base.with_suffix(".csv")
    if csv.exists():
        return csv
    return None

def read_table(analytics_dir: Path, base_name: str) -> pd.DataFrame:
    """
    Reads per-scenario table written by run_analytics.py via write_df(..., base_name, ...).
    Supports .xlsx (sheet 'data') and .csv.
    """
    path = _find_first_existing(analytics_dir / base_name)
    if not path:
        return pd.DataFrame()
    if path.suffix.lower() == ".xlsx":
        return pd.read_excel(path, sheet_name="data", engine="openpyxl")
    return pd.read_csv(path)

def read_master_excel(analytics_dir: Path) -> Dict[str, pd.DataFrame]:
    """
    Reads master_analytics.xlsx (sheets correspond to scenarios).
    """
    master_path = analytics_dir / "master_analytics.xlsx"
    if not master_path.exists():
        return {}
    try:
        xls = pd.ExcelFile(master_path, engine="openpyxl")
        sheets = {}
        for s in xls.sheet_names:
            try:
                sheets[s] = pd.read_excel(xls, sheet_name=s)
            except Exception:
                sheets[s] = pd.DataFrame()
        return sheets
    except Exception:
        return {}

def read_summary_json(analytics_dir: Path) -> Dict:
    p = analytics_dir / "_logs" / "analytics_summary.json"
    if not p.exists():
        return {}
    try:
        return json.loads(p.read_text(encoding="utf-8"))
    except Exception:
        return {}

def metric_box(label: str, value, help_text: Optional[str] = None):
    col = st.columns(1)[0]
    col.metric(label, value)
    if help_text:
        st.caption(help_text)

def df_download(name: str, df: pd.DataFrame):
    if df is None or df.empty:
        return
    data = df.to_csv(index=False).encode("utf-8")
    st.download_button(
        label=f"Download {name}.csv",
        data=data,
        file_name=f"{name}.csv",
        mime="text/csv",
        use_container_width=True,
    )

def bar_from_series(s: pd.Series, title: str, n: int = 20):
    if s is None or s.empty:
        st.info("No data to plot.")
        return
    df = s.head(n).rename_axis("key").reset_index(name="count")
    fig = px.bar(df, x="key", y="count", title=title, text_auto=True)
    fig.update_layout(xaxis_title=None, yaxis_title="Count")
    st.plotly_chart(fig, use_container_width=True)

def try_plot_timeseries(df: pd.DataFrame, x_col: str, y_col: str, title: str):
    if df.empty or x_col not in df.columns or y_col not in df.columns:
        st.info("Timeseries not available.")
        return
    # Ensure proper ordering for month period strings like '2025-10'
    try:
        x_sorted = pd.to_datetime(df[x_col], format="%Y-%m", errors="coerce")
        df_plot = df.assign(_x=x_sorted).sort_values("_x")
        fig = px.line(df_plot, x=x_col, y=y_col, markers=True, title=title)
    except Exception:
        fig = px.line(df, x=x_col, y=y_col, markers=True, title=title)
    st.plotly_chart(fig, use_container_width=True)

# ---------- UI ----------
st.set_page_config(page_title="Run Analytics Dashboard", layout="wide")
st.title("Run Analytics – Consolidated Dashboard")
st.caption("Visualize outputs produced by `run_analytics.py`: coverage, quality, and per-scenario aggregates.")

# Sidebar: select root & run
root_input = st.sidebar.text_input("Output root folder", str(DEFAULT_OUT_ROOT))
out_root = Path(root_input).resolve()
runs = list_runs(out_root)

if not runs:
    st.warning(f"No runs found under: {out_root}\n\nCreate runs under this folder, then execute run_analytics.py.")
    st.stop()

run_names = [r.name for r in runs]
sel_run_name = st.sidebar.selectbox("Select run", run_names, index=0)
sel_run = out_root / sel_run_name
analytics_dir = compute_analytics_dir(sel_run)

if not analytics_dir.exists():
    st.error(
        f"Analytics folder not found: {analytics_dir}\n\n"
        "Please run the consolidator:\n"
        "  python run_analytics.py --run-dir " + str(sel_run)
    )
    st.stop()

st.markdown(f"**Run folder:** `{sel_run}`")
st.markdown(f"**Analytics folder:** `{analytics_dir}`")
st.divider()

# ---------- Overview & Quality ----------
summary_json = read_summary_json(analytics_dir)
master_sheets = read_master_excel(analytics_dir)

c_top1, c_top2, c_top3, c_top4 = st.columns(4)

total_rows = summary_json.get("total_rows", 0)
coverage_pct = summary_json.get("coverage_pct", 0.0)
coverage_non_misc = summary_json.get("coverage_non_misc", 0)
qc = summary_json.get("quality_checks", {}) or {}

with c_top1:
    st.metric("Total rows (all groups)", f"{int(total_rows):,}")
with c_top2:
    st.metric("Coverage (non-misc)", f"{float(coverage_pct):.1f}%")
with c_top3:
    st.metric("Missing primary_interface", f"{float(qc.get('pct_missing_primary_interface', 0.0))*100:.1f}%")
with c_top4:
    st.metric("error_family == 'other'", f"{float(qc.get('pct_error_family_other', 0.0))*100:.1f}%")

st.caption(
    f"Rows with stuck metrics: {int(qc.get('rows_with_stuck_metrics', 0)):,} | "
    f"Rows with FTP metadata: {int(qc.get('rows_with_ftp_metadata', 0)):,} | "
    f"Generated: {summary_json.get('generated_at', '-')}"
)

# Group counts bar
group_counts = summary_json.get("group_counts", {})
if group_counts:
    gdf = pd.DataFrame(
        sorted(group_counts.items(), key=lambda x: x[0]),
        columns=["group", "count"]
    )
    fig_gc = px.bar(gdf, x="group", y="count", title="Counts by scenario (from consolidator)", text_auto=True)
    st.plotly_chart(fig_gc, use_container_width=True)
else:
    st.info("No `group_counts` found in analytics_summary.json")

# Top offenders (interfaces)
top_offenders = summary_json.get("top_offenders_interfaces", [])
if top_offenders:
    offenders_df = pd.DataFrame(top_offenders)
    fig_to = px.bar(
        offenders_df,
        x="primary_interface",
        y="incidents_count",
        title="Top offenders (interfaces, across all scenarios)",
        text_auto=True,
    )
    fig_to.update_layout(xaxis_title="primary_interface", yaxis_title="incidents_count")
    st.plotly_chart(fig_to, use_container_width=True)
else:
    st.info("No 'top_offenders_interfaces' present in analytics summary.")

st.divider()

# ---------- Scenario Tabs ----------
tab_labels = [
    "Overview",
    "Stuck files",
    "FTP errors",
    "Config file",
    "ERR-FILE-REMOVE",
    "Callout MFTERR03",
    "Callout MFTERR04",
    "Process alert",
    "Warnings",
    "Misc"
]
(
    tab_overview,
    tab_stuck,
    tab_ftp,
    tab_cfg,
    tab_errrm,
    tab_co3,
    tab_co4,
    tab_proc,
    tab_warn,
    tab_misc,
) = st.tabs(tab_labels)

# -------- Overview tab: master sheets quick peek --------
with tab_overview:
    st.subheader("Master workbook (quick peek)")
    if master_sheets:
        sheet_names = list(master_sheets.keys())
        sheet_sel = st.selectbox("Open master sheet", sheet_names, index=0)
        dfm = master_sheets.get(sheet_sel, pd.DataFrame())
        st.dataframe(dfm.head(PREVIEW_LIMIT), use_container_width=True, height=400)
        df_download(f"master_{sheet_sel}", dfm)
    else:
        st.info("`master_analytics.xlsx` not found or no readable sheets present.")

# -------- Stuck files --------
with tab_stuck:
    st.subheader("Stuck files")
    df_counts = read_table(analytics_dir, "stuck_paths_counts")
    df_stats = read_table(analytics_dir, "stuck_paths_stats")
    df_top_iface = read_table(analytics_dir, "stuck_top_interfaces")

    c1, c2 = st.columns(2)
    with c1:
        st.markdown("**Paths by incidents_count**")
        if not df_counts.empty:
            fig = px.bar(df_counts.head(30), x="path", y="incidents_count", title="Top stuck paths", text_auto=True)
            fig.update_layout(xaxis_title=None, yaxis_title="incidents_count")
            st.plotly_chart(fig, use_container_width=True)
            df_download("stuck_paths_counts", df_counts)
        else:
            st.info("No `stuck_paths_counts` table.")

    with c2:
        st.markdown("**Top interfaces**")
        if not df_top_iface.empty:
            fig2 = px.bar(df_top_iface.head(30), x="primary_interface", y="incidents_count",
                          title="Stuck incidents by interface", text_auto=True)
            st.plotly_chart(fig2, use_container_width=True)
            df_download("stuck_top_interfaces", df_top_iface)
        else:
            st.info("No `stuck_top_interfaces` table.")

    st.markdown("**Path-level stats**")
    if not df_stats.empty:
        st.dataframe(df_stats.head(PREVIEW_LIMIT), use_container_width=True, height=400)
        df_download("stuck_paths_stats", df_stats)
    else:
        st.info("No `stuck_paths_stats` table.")

# -------- FTP errors --------
with tab_ftp:
    st.subheader("FTP errors")
    df_verb = read_table(analytics_dir, "ftp_by_verb")
    df_code = read_table(analytics_dir, "ftp_by_code")
    df_key = read_table(analytics_dir, "ftp_iface_verb_code")
    df_perm = read_table(analytics_dir, "ftp_permission_connectivity")

    c1, c2 = st.columns(2)
    with c1:
        st.markdown("**By FTP verb**")
        if not df_verb.empty:
            fig = px.bar(df_verb, x="ftp_command", y="incidents_count", title="FTP verbs", text_auto=True)
            st.plotly_chart(fig, use_container_width=True)
            df_download("ftp_by_verb", df_verb)
        else:
            st.info("No `ftp_by_verb` table.")

    with c2:
        st.markdown("**By FTP code**")
        if not df_code.empty:
            fig2 = px.bar(df_code, x="ftp_code", y="incidents_count", title="FTP codes", text_auto=True)
            st.plotly_chart(fig2, use_container_width=True)
            df_download("ftp_by_code", df_code)
        else:
            st.info("No `ftp_by_code` table.")

    st.markdown("**Interface × Verb × Code**")
    if not df_key.empty:
        st.dataframe(df_key.head(PREVIEW_LIMIT), use_container_width=True, height=360)
        df_download("ftp_iface_verb_code", df_key)
    else:
        st.info("No `ftp_iface_verb_code` table.")

    st.markdown("**Permission vs Not connected (per interface)**")
    if not df_perm.empty:
        melt_cols = ["permission_denied", "not_connected"]
        plot_df = df_perm.melt(
            id_vars=["primary_interface", "incidents_count"],
            value_vars=melt_cols,
            var_name="category", value_name="count"
        )
        fig3 = px.bar(plot_df, x="primary_interface", y="count", color="category",
                      title="Permission/Connectivity signals by interface", barmode="group")
        st.plotly_chart(fig3, use_container_width=True)
        df_download("ftp_permission_connectivity", df_perm)
    else:
        st.info("No `ftp_permission_connectivity` table.")

# -------- Config file --------
with tab_cfg:
    st.subheader("Config file")
    df_bad = read_table(analytics_dir, "config_bad_paths")
    df_top = read_table(analytics_dir, "config_top_interfaces")

    c1, c2 = st.columns(2)
    with c1:
        st.markdown("**Bad config paths**")
        if not df_bad.empty:
            fig = px.bar(df_bad.head(40), x="path", y="incidents_count", title="Bad config paths", text_auto=True)
            st.plotly_chart(fig, use_container_width=True)
            df_download("config_bad_paths", df_bad)
        else:
            st.info("No `config_bad_paths` table.")
    with c2:
        st.markdown("**Top interfaces**")
        if not df_top.empty:
            fig2 = px.bar(df_top.head(40), x="primary_interface", y="incidents_count", title="Config incidents by interface", text_auto=True)
            st.plotly_chart(fig2, use_container_width=True)
            df_download("config_top_interfaces", df_top)
        else:
            st.info("No `config_top_interfaces` table.")

# -------- ERR-FILE-REMOVE --------
with tab_errrm:
    st.subheader("ERR-FILE-REMOVE")
    df_by_iface = read_table(analytics_dir, "err_remove_by_interface")
    df_paths = read_table(analytics_dir, "err_remove_paths")

    c1, c2 = st.columns(2)
    with c1:
        st.markdown("**By interface**")
        if not df_by_iface.empty:
            fig = px.bar(df_by_iface.head(40), x="primary_interface", y="incidents_count", title="ERR-FILE-REMOVE by interface", text_auto=True)
            st.plotly_chart(fig, use_container_width=True)
            df_download("err_remove_by_interface", df_by_iface)
        else:
            st.info("No `err_remove_by_interface` table.")
    with c2:
        st.markdown("**By filesystem path**")
        if not df_paths.empty:
            fig2 = px.bar(df_paths.head(40), x="path", y="incidents_count", title="ERR-FILE-REMOVE by path", text_auto=True)
            st.plotly_chart(fig2, use_container_width=True)
            df_download("err_remove_paths", df_paths)
        else:
            st.info("No `err_remove_paths` table.")

# -------- Callout MFTERR03 --------
with tab_co3:
    st.subheader("Callout MFTERR03")
    df_ifaces = read_table(analytics_dir, "callout_mfterr03_interfaces")
    df_hosts = read_table(analytics_dir, "callout_mfterr03_hosts")

    c1, c2 = st.columns(2)
    with c1:
        st.markdown("**Interfaces**")
        if not df_ifaces.empty:
            fig = px.bar(df_ifaces.head(40), x="primary_interface", y="incidents_count", title="Callout03 by interface", text_auto=True)
            st.plotly_chart(fig, use_container_width=True)
            df_download("callout_mfterr03_interfaces", df_ifaces)
        else:
            st.info("No `callout_mfterr03_interfaces` table.")
    with c2:
        st.markdown("**Hosts**")
        if not df_hosts.empty:
            fig2 = px.bar(df_hosts.head(40), x="host_tag", y="incidents_count", title="Callout03 by host", text_auto=True)
            st.plotly_chart(fig2, use_container_width=True)
            df_download("callout_mfterr03_hosts", df_hosts)
        else:
            st.info("No `callout_mfterr03_hosts` table.")

# -------- Callout MFTERR04 --------
with tab_co4:
    st.subheader("Callout MFTERR04")
    df_ifaces = read_table(analytics_dir, "callout_mfterr04_interfaces")
    df_hosts = read_table(analytics_dir, "callout_mfterr04_hosts")

    c1, c2 = st.columns(2)
    with c1:
        st.markdown("**Interfaces**")
        if not df_ifaces.empty:
            fig = px.bar(df_ifaces.head(40), x="primary_interface", y="incidents_count", title="Callout04 by interface", text_auto=True)
            st.plotly_chart(fig, use_container_width=True)
            df_download("callout_mfterr04_interfaces", df_ifaces)
        else:
            st.info("No `callout_mfterr04_interfaces` table.")
    with c2:
        st.markdown("**Hosts**")
        if not df_hosts.empty:
            fig2 = px.bar(df_hosts.head(40), x="host_tag", y="incidents_count", title="Callout04 by host", text_auto=True)
            st.plotly_chart(fig2, use_container_width=True)
            df_download("callout_mfterr04_hosts", df_hosts)
        else:
            st.info("No `callout_mfterr04_hosts` table.")

# -------- Process alert --------
with tab_proc:
    st.subheader("Process alert")
    df_by_iface = read_table(analytics_dir, "process_alert_by_interface")
    df_time = read_table(analytics_dir, "process_alert_time")

    c1, c2 = st.columns(2)
    with c1:
        st.markdown("**By interface**")
        if not df_by_iface.empty:
            fig = px.bar(df_by_iface.head(40), x="primary_interface", y="incidents_count", title="Process-alert by interface", text_auto=True)
            st.plotly_chart(fig, use_container_width=True)
            df_download("process_alert_by_interface", df_by_iface)
        else:
            st.info("No `process_alert_by_interface` table.")
    with c2:
        st.markdown("**By month**")
        if not df_time.empty:
            try_plot_timeseries(df_time, "month", "incidents_count", "Process-alert incidents by month")
            df_download("process_alert_time", df_time)
        else:
            st.info("No `process_alert_time` table.")

# -------- Warnings --------
with tab_warn:
    st.subheader("Warnings")
    df_hosts = read_table(analytics_dir, "warnings_hosts")
    df_paths = read_table(analytics_dir, "warnings_fs_paths")

    c1, c2 = st.columns(2)
    with c1:
        st.markdown("**Hosts**")
        if not df_hosts.empty:
            fig = px.bar(df_hosts.head(40), x="host_tag", y="incidents_count", title="Warnings by host", text_auto=True)
            st.plotly_chart(fig, use_container_width=True)
            df_download("warnings_hosts", df_hosts)
        else:
            st.info("No `warnings_hosts` table.")
    with c2:
        st.markdown("**Filesystem paths**")
        if not df_paths.empty:
            fig2 = px.bar(df_paths.head(40), x="path", y="incidents_count", title="Warnings by path", text_auto=True)
            st.plotly_chart(fig2, use_container_width=True)
            df_download("warnings_fs_paths", df_paths)
        else:
            st.info("No `warnings_fs_paths` table.")

# -------- Misc --------
with tab_misc:
    st.subheader("Misc triage")
    df_tokens = read_table(analytics_dir, "misc_top_tokens")
    df_codes = read_table(analytics_dir, "misc_error_codes")

    c1, c2 = st.columns(2)
    with c1:
        st.markdown("**Top tokens (from Short description)**")
        if not df_tokens.empty:
            fig = px.bar(df_tokens.head(40), x="token", y="count", title="Top tokens", text_auto=True)
            st.plotly_chart(fig, use_container_width=True)
            df_download("misc_top_tokens", df_tokens)
        else:
            st.info("No `misc_top_tokens` table.")
    with c2:
        st.markdown("**Error codes**")
        if not df_codes.empty:
            fig2 = px.bar(df_codes.head(40), x="error_code", y="count", title="Error codes", text_auto=True)
            st.plotly_chart(fig2, use_container_width=True)
            df_download("misc_error_codes", df_codes)
        else:
            st.info("No `misc_error_codes` table.")
